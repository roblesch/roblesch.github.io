---
layout: post
title:  "Albedo to EARS, Pt. 6 - Statistical Accumulators & The EARS Integrator"
date:   2023-03-28
author: Christian Robles
category: blog
image: "/assets/images/ears/ears-iter-compare.jpg"
description: "Hello again! It's been awhile - this post was pushed back a week to give me some time to relax over Spring Break. I took the chance to visit Death Valley before the weather turns ugly. Death Valley's Badwater Basin is the lowest point in North America and is only 84.6 miles from the highest point in the (contiguous) United States - Mount Whitney."
published: true 
---

Hello again! It's been awhile - this post was pushed back a week to give me some time to relax over Spring Break. I took the chance to visit Death Valley before the weather turns ugly. Death Valley's Badwater Basin is the lowest point in North America and is only 84.6 miles from the highest point in the (contiguous) United States - Mount Whitney.

<figure>
    <img src="/assets/images/ears/badwater-basin.jpeg" />
    <figcaption>Badwater Basin and Telescope Peak. Hot and salty!</figcaption>
</figure>

Anyway, back to EARS. A quick recap on progress so far - parts 1 - 3 implemented the base rendering framework that would be extended with ADRRS and EARS. Part 4 introduced Intel's Open Image Denoise and the octtree that caches the directional variance histograms used to select RRS values. In part 5, I implemented the EARS formulation of forward path tracing used to traverse paths, perform RRS and produce per-pixel estimates. In this post, I'll discuss how I implemented the statistical accumulators that store the results of each iteration, and how all of these pieces are brought together in the EARS integrator.

As usual, some results -

<figure>
    <a href="/assets/images/ears/ears-iter-compare.jpg">
        <img src="/assets/images/ears/ears-iter-compare.jpg" />
    </a>
    <figcaption>EARS integration, 8 iterations, 1spp (Click to enlarge)</figcaption>
</figure>

Above are the results of the first 8 iterations of images generated by training RRS parameters over the scene. Clearly something isn't working as expected - the average variance over the image is diverging after each iteration rather than converging. I'll explain my thoughts on likely causes and my plan to get these fixed later in the post.

Project proposal: [project-proposal.pdf](/assets/roblesch_project_proposal.pdf)

First post in the series: [Directed Research at USC](https://blog.roblesch.page/blog/2022/11/17/directed-research.html)

GitHub repository: [roblesch/roulette](https://github.com/roblesch/roulette)

## Statistical Accumulators

There are two statistical accumulators that contribute to iteration of the EARS integrator. The first is the *spatial cache* (octtree) discussed and implemented in previous posts, which stores the estimated reflected radiance $$L_r$$ and its estimated cost of calculation. The cache bins these estimates for each bounce along the path so that future paths can check the cache to find their nearest estimate and use this estimate as part of the calculation whether to perform russian roulette or split.

Original implementation: [irath96/ears/octtree.h/Octtree](https://github.com/iRath96/ears/blob/master/mitsuba/src/integrators/path/octtree.h)

The second accumulator is the *image statistics*. The image statistics accumulate the per-pixel relative MSE against the image estimate, produced by denoising. The image statistics performs outlier rejection to prevent especially noisy pixels from overly biasing the estimated variance over the image. These statistics are also used in determining an appropriate RRS value along each path.

Original implementation: [irath96/ears/recursive_path.cpp/ImageStatistics](https://github.com/iRath96/ears/blob/5ad0a6a8131c164b75417f03b4578076c6ac0372/mitsuba/src/integrators/path/recursive_path.cpp#L1473)

## Integrator

With the spatial cache, the tracer, denoising, and image statistics, all the pieces are in place to begin using the EARS algorithm to generate RRS values. The piece that brings all of these steps together is the *integrator*. The integrator performs multiple iterations over the image, trains the cache, stores variance estimates in the image statistics, performs denoising to produce an image estimate, and merges estimates by variance.

It looks something like this:

```
EARSIntegrator::render(Scene scene, FrameBuffer frame):
    // render the albedo and normals for denoising
    albedo, normals = renderDenoisingAuxillaries(scene)
    spatialCache = initializeSpatialCache()
    imageStatistics = initializeImageStatistics()
    finalImage = initializeFinalImage()
    foreach iteration in timeBudget:
        rrsMethod = iteration < 3 ? Classic() : EARS()
        iterationImg.clear()
        foreach spp in iterationTimeBudget:
            foreach pixel in image:
                iterationImg.add(earsTracer.trace(pixel))
        // reject variance outliers
        imageStatistics.applyOutlierRejection()
        // train the cache
        spatialCache.rebuild()
        // merge images by variance
        finalImage.add(iterationImg, spp, imageStatistics.avgVariance())
        // produce a denoised estimate
        earsTracer.denoised = OIDN::denoise(iterationImg, albedo, normals)
    frame.result = finalImage.develop()
```

Original implementation: [irath96/ears/recursive_path.cpp/render(), renderTime(), renderBlock()](https://github.com/iRath96/ears/blob/5ad0a6a8131c164b75417f03b4578076c6ac0372/mitsuba/src/integrators/path/recursive_path.cpp#L1473)

## Issues

<figure>
    <img src="/assets/images/ears/ears-variance-diverge.png" />
    <figcaption>That's supposed to go down...</figcaption>
</figure>

Something isn't working out. There are a handful of sources of error, each of which are quite hard to pin down without solid references to debug against. It could be that the cache is not properly updating or that the values are improperly weighted. Or, the image statistics could have similar issues.

There is a difference in iteration time - my renderer is single-threaded on the CPU and Mitsuba is GPU-accelerated, so the render times will be vastly quicker. I experimented with some Vulkan code samples for GPU-accelerated PBR, and the accelerated tracer can perform a couple hundred spps in the time that my renderer can produce one. I can work around this by forcing a number of iterations and SPP, which I might derive from some of the supplemental charts provided with the paper.

Additionally, in the authors implementation image statistics perform outlier rejection per-block rather than per-image-iteration, meaning that more outliers are rejected more frequently.

## Next Time

I have a lot of painful debugging ahead of me - but the end is in sight. With all the pieces in place, all that's left to do is tune them up. Check in next time to see if I was able to get things working. As always, thank you for reading.

### Footnotes

I have big dreams of wrapping this project in an interactive GPU-accelerated hybrid renderer with Vulkan. For now, I just wanted to mess around with [ImGui](https://github.com/ocornut/imgui), so I wrapped the outputs in GLFW and drew it to a texture with some buttons.

<figure>
    <img src="/assets/images/ears/glfw-imgui.png" width=400 />
    <figcaption>Neat!</figcaption>
</figure>

- [Pt. 1 - Project Introduction](https://blog.roblesch.page/blog/2023/01/04/ears-1.html)
- [Pt. 2 - Base Renderer Implementation](https://blog.roblesch.page/blog/2023/01/17/ears-2.html)
- [Pt. 3 - Renderer Debugging and Literature Review of RRS](https://blog.roblesch.page/blog/2023/02/07/ears-3.html)
- [Pt. 4 - Denoising and the Spatial Cache](https://blog.roblesch.page/blog/2023/02/21/ears-4.html)
- [Pt. 5 - The EARS Tracer](https://blog.roblesch.page/blog/2023/03/07/ears-5.html)
- [Pt. 6 - Statistical Accumulators](https://blog.roblesch.page/blog/2023/03/28/ears-6.html)
- [Pt. 7 - Final Results](https://blog.roblesch.page/blog/2023/04/11/ears-7.html)
